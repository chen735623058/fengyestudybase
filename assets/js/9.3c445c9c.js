(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{193:function(t,a,s){"use strict";s.r(a);var n=s(0),e=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"js部分面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js部分面试题","aria-hidden":"true"}},[t._v("#")]),t._v(" JS部分面试题")]),t._v(" "),s("h2",{attrs:{id:"事件委托的解释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件委托的解释","aria-hidden":"true"}},[t._v("#")]),t._v(" 事件委托的解释")]),t._v(" "),s("blockquote",[s("p",[t._v("事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器。当触发子元素时，事件会冒泡到父元素，监听器就会触发。这种技术的好处是：")])]),t._v(" "),s("p",[t._v("内存占用减少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。\n无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。")]),t._v(" "),s("h2",{attrs:{id:"对-amd-和-commonjs-的了解。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对-amd-和-commonjs-的了解。","aria-hidden":"true"}},[t._v("#")]),t._v(" 对 AMD 和 CommonJS 的了解。")]),t._v(" "),s("blockquote",[s("p",[t._v("它们都是实现模块体系的方式，直到 ES2015 出现之前，JavaScript 一直没有模块体系。CommonJS 是同步的，而 AMD（Asynchronous Module Definition）从全称中可以明显看出是异步的。CommonJS 的设计是为服务器端开发考虑的，而 AMD 支持异步加载模块，更适合浏览器。")])]),t._v(" "),s("blockquote",[s("p",[t._v("我发现 AMD 的语法非常冗长，CommonJS 更接近其他语言 import 声明语句的用法习惯。大多数情况下，我认为 AMD 没有使用的必要，因为如果把所有 JavaScript 都捆绑进一个文件中，将无法得到异步加载的好处。此外，CommonJS 语法上更接近 Node 编写模块的风格，在前后端都使用 JavaScript 开发之间进行切换时，语境的切换开销较小。")])]),t._v(" "),s("h2",{attrs:{id:"请解释下面代码为什么不能用作-iife：function-foo-，需要作出哪些修改才能使其成为-iife？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请解释下面代码为什么不能用作-iife：function-foo-，需要作出哪些修改才能使其成为-iife？","aria-hidden":"true"}},[t._v("#")]),t._v(" 请解释下面代码为什么不能用作 IIFE：function foo(){ }();，需要作出哪些修改才能使其成为 IIFE？")]),t._v(" "),s("blockquote",[s("p",[t._v("IIFE（Immediately Invoked Function Expressions）代表立即执行函数。 JavaScript 解析器将 function foo(){ }();解析成function foo(){ }和();。其中，前者是函数声明；后者（一对括号）是试图调用一个函数，却没有指定名称，因此它会抛出Uncaught SyntaxError: Unexpected token )的错误。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h2",{attrs:{id:"null、undefined和未声明变量之间有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#null、undefined和未声明变量之间有什么区别","aria-hidden":"true"}},[t._v("#")]),t._v(" null、undefined和未声明变量之间有什么区别")]),t._v(" "),s("blockquote",[s("ol",[s("li",[t._v("当一个变量已经声明，但没有赋值时，该变量的值是undefined")]),t._v(" "),s("li",[t._v("ull只能被显式赋值给变量。它表示空值，与被显式赋值 undefined 的意义不同")]),t._v(" "),s("li",[t._v("未声明变量是在声明之前就进行赋值的变量，他作为windos对象的一个属性存在")])])]),t._v(" "),s("h2",{attrs:{id:"请说明-foreach循环和-map-循环的主要区别，它们分别在什么情况下使用？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请说明-foreach循环和-map-循环的主要区别，它们分别在什么情况下使用？","aria-hidden":"true"}},[t._v("#")]),t._v(" 请说明.forEach循环和.map()循环的主要区别，它们分别在什么情况下使用？")]),t._v(" "),s("p",[t._v("forEach")]),t._v(" "),s("ul",[s("li",[t._v("遍历数组中的元素。")]),t._v(" "),s("li",[t._v("为每个元素执行回调。")]),t._v(" "),s("li",[t._v("无返回值。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" doubled "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("num"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行与 num、index 相关的代码")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// doubled = undefined")]),t._v("\n")])])]),s("p",[t._v("map")]),t._v(" "),s("ul",[s("li",[t._v("遍历数组中的元素")]),t._v(" "),s("li",[t._v("通过对每个元素调用函数，将每个元素“映射（map）”到一个新元素，从而创建一个新数组。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" doubled "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("num "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" num "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// doubled = [2, 4, 6]")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v(".forEach和.map()的主要区别在于.map()返回一个新的数组。如果你想得到一个结果，但不想改变原始数组，用.map()。如果你只需要在数组上做迭代修改，用forEach。")])]),t._v(" "),s("h2",{attrs:{id:"匿名函数的典型应用场景是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#匿名函数的典型应用场景是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 匿名函数的典型应用场景是什么？")]),t._v(" "),s("blockquote",[s("ol",[s("li",[t._v("IIFE中")]),t._v(" "),s("li",[t._v("一次使用的函数")]),t._v(" "),s("li",[t._v("函数式编程")])])]),t._v(" "),s("h2",{attrs:{id:"宿主对象（host-objects）和原生对象（native-objects）的区别是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宿主对象（host-objects）和原生对象（native-objects）的区别是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 宿主对象（host objects）和原生对象（native objects）的区别是什么？")]),t._v(" "),s("blockquote",[s("p",[t._v("原生对象是由 ECMAScript 规范定义的 JavaScript 内置对象，比如String、Math、RegExp、Object、Function等等。\n宿主对象是由运行时环境（浏览器或 Node）提供，比如window、XMLHTTPRequest等等。")])]),t._v(" "),s("h2",{attrs:{id:"请说明-jsonp-的工作原理，它为什么不是真正的-ajax"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请说明-jsonp-的工作原理，它为什么不是真正的-ajax","aria-hidden":"true"}},[t._v("#")]),t._v(" 请说明 JSONP 的工作原理，它为什么不是真正的 Ajax")]),t._v(" "),s("blockquote",[s("p",[t._v("JSONP（带填充的 JSON）是一种通常用于绕过 Web 浏览器中的跨域限制的方法，因为 Ajax 不允许跨域请求。 现在更多的是用CORS (跨域资源共享)\n都能解决 Ajax直接请求普通文件存在跨域无权限访问的问题")])]),t._v(" "),s("ol",[s("li",[t._v("JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求")]),t._v(" "),s("li",[t._v("使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理")]),t._v(" "),s("li",[t._v("JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS")])]),t._v(" "),s("h3",{attrs:{id:"cors-实现思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cors-实现思路","aria-hidden":"true"}},[t._v("#")]),t._v(" CORS 实现思路")]),t._v(" "),s("p",[t._v("CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否")]),t._v(" "),s("h2",{attrs:{id:"你使用过-javascript-模板吗？用过什么相关的库？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你使用过-javascript-模板吗？用过什么相关的库？","aria-hidden":"true"}},[t._v("#")]),t._v(" 你使用过 JavaScript 模板吗？用过什么相关的库？")]),t._v(" "),s("p",[t._v("使用过。VUE、AngularJS 和 JSX。我不喜欢 AngularJS 中的模板，因为它在指令中大量使用了字符串，并且书写错误会被忽略。JSX 是我的新宠，因为它更接近 JavaScript，几乎没有什么学习成本。现在，可以使用 ES2015 模板字符串快速创建模板，而不需依赖第三方代码。")]),t._v(" "),s("h2",{attrs:{id:"你对-promises-及其-polyfill-的掌握程度如何？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你对-promises-及其-polyfill-的掌握程度如何？","aria-hidden":"true"}},[t._v("#")]),t._v(" 你对 Promises 及其 polyfill 的掌握程度如何？")]),t._v(" "),s("blockquote",[s("p",[t._v("掌握它的工作原理。Promise是一个可能在未来某个时间产生结果的对象：操作成功的结果或失败的原因（例如发生网络错误）。 Promise可能处于以下三种状态之一：fulfilled、rejected 或 pending。 用户可以对Promise添加回调函数来处理操作成功的结果或失败的原因。")])]),t._v(" "),s("blockquote",[s("p",[t._v("一些常见的 polyfill 是$.deferred、Q 和 Bluebird，但不是所有的 polyfill 都符合规范。ES2015 支持 Promises，现在通常不需要使用 polyfills。")])]),t._v(" "),s("h2",{attrs:{id:"promise代替回调函数有什么优缺点？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise代替回调函数有什么优缺点？","aria-hidden":"true"}},[t._v("#")]),t._v(" Promise代替回调函数有什么优缺点？")]),t._v(" "),s("blockquote",[s("ol",[s("li",[t._v("避免可读性极差的回调地狱。")]),t._v(" "),s("li",[t._v("使用.then()编写的顺序异步代码，既简单又易读。")]),t._v(" "),s("li",[t._v("使用Promise.all()编写并行异步代码变得很容易。")])])]),t._v(" "),s("blockquote",[s("ol",[s("li",[t._v("轻微地增加了代码的复杂度（这点存在争议）。")]),t._v(" "),s("li",[t._v("在不支持 ES2015 的旧版浏览器中，需要引入 polyfill 才能使用。")])])])])}],!1,null,null,null);a.default=e.exports}}]);